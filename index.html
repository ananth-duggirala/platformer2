<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Gamedev Canvas Workshop</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        canvas {
            background: #eee;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>

<body>

    <canvas id="myCanvas" width="800" height="900"></canvas>

    <script>
        // JavaScript code goes here

        class RectangularPlatform {
            width;
            height;
            constructor(x1, y1, x2, y2) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                this.height = y2 - y1;
                this.width = x2 - x1;
                // drawPlatform(ctx);
            }

            drawPlatform(ctx) {
                ctx.beginPath();
                ctx.rect(this.x1, this.y1, this.width, this.height);
                ctx.fillStyle = "#0095DD";
                ctx.fill();
                ctx.closePath();
            }
        }

        class User {
            constructor(x, y, radius, x_vel, y_vel) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.x_vel = x_vel;
                this.y_vel = y_vel;
            }

            drawUser(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); //change this back
                ctx.fillStyle = "#0095DD";
                ctx.fill();
                ctx.closePath();
            }
        }

        class Agent {
            constructor(x, y, radius, x_vel, y_vel) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.x_vel = x_vel;
                this.y_vel = y_vel;
            }

            drawAgent(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = "#FF6347";
                ctx.fill();
                ctx.closePath();
            }
        }

        function isReachable(from_x, from_y, to_x, to_y) {
            horizontal_distance = Math.abs(to_x - from_x);
            vertical_distance = Math.abs(to_y - from_y);
            time_to_reach_vertical_distance = (AGENT_Y_VEL + Math.sqrt(AGENT_Y_VEL * AGENT_Y_VEL - 2 * G * vertical_distance)) / G; // quadratic formula
            console.log("h_dist = " + horizontal_distance + " v_dist = " + vertical_distance + " time_avail =  " + time_to_reach_vertical_distance + " x1 " + from_x + " y1 " + from_y + " x2 " + to_x + " y2 " + to_y);
            return (AGENT_X_VEL * time_to_reach_vertical_distance > horizontal_distance);
        }

        function loadMap(canvas) {
            var platforms = [];
            for (var i = 0; i < 4; i++) {
                x1 = i * canvas.width / 4;
                y1 = (4 - i) * canvas.height / 4;
                x2 = x1 + 60;
                y2 = y1 - 10;
                platforms.push(new RectangularPlatform(x1, y1, x2, y2));
            }

            platforms.push(new RectangularPlatform(0, canvas.height - 500, 60, canvas.height - 520));
            return platforms;
        }

        var canvas = document.getElementById("myCanvas");
        var ctx = canvas.getContext("2d");

        var x = canvas.width / 16;

        var ballRadius = 15;
        var y = canvas.height - ballRadius;
        var dx = 0;
        var dy = 0;
        var platformWidth = 60;
        var platformHeight = 10;

        var maxBallSpeed = 4;
        var AGENT_X_VEL = 1.5;
        var AGENT_Y_VEL = 7.5;
        X_ACCL = 0.3;

        var G = 0.1 // gravitational acceleration


        var user = new User(x, y, ballRadius, dx, dy);
        var platforms = loadMap(canvas);

        var agents = [
            new Agent(canvas.width - 200, canvas.height - 20, 20, 0, 0),
            new Agent(canvas.width - 150, canvas.height - 20, 20, 0, 0)
        ];

        console.log(isReachable(platforms[0].x2, platforms[0].y2, platforms[1].x1, platforms[1].y2, 1.5, 7.5));

        var reachabilityGraph = [];
        for (var i = 0; i < platforms.length; i++)
            reachabilityGraph.push([]);

        for (var i = 0; i < platforms.length; i++) {
            for (var j = i + 1; j < platforms.length; j++) {
                console.log("i " + i + " j " + j);
                var reachable = false;

                if (platforms[j].x2 < platforms[i].x1) { // case 2
                    reachable = isReachable(platforms[i].x1, platforms[i].y2, platforms[j].x2, platforms[j].y2);
                } else if (platforms[j].x1 > platforms[i].x2) { // case 1
                    reachable = isReachable(platforms[i].x2, platforms[i].y2, platforms[j].x1, platforms[j].y2);
                } else { // case 3
                    reachable = (AGENT_Y_VEL * AGENT_Y_VEL) / (2 * G) >= Math.abs(platforms[i].y2 - platforms[j].y2);
                }

                if (reachable) {
                    reachabilityGraph[i].push(j);
                    reachabilityGraph[j].push(i);
                }

            }
        }
        for (var i = 0; i < platforms.length; i++) {
            console.log(i + " -> " + reachabilityGraph[i]);
        }

        var rightPressed = false;
        var leftPressed = false;
        var upPressed = false;
        var time = 0;

        class CollisionDetection {
            constructor(width, height, user, platforms, agents, g) {
                this.width = width;
                this.height = height;
                this.user = user;
                this.platforms = platforms;
                this.g = g;
                this.agents = agents;
            }

            distSq(x1, y1, x2, y2) {
                return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);
            }

            detectCollisionWithAgentAndUpdate() {
                for (var i = 0; i < this.agents.length; i++) {
                    // 1. Detect collision with side and top walls 
                    if (this.agents[i].x + this.agents[i].x_vel > this.width - this.agents[i].radius ||
                        this.agents[i].x + this.agents[i].x_vel < this.agents[i].radius) {
                        this.agents[i].x_vel = -this.agents[i].x_vel;
                    }
                    if (this.agents[i].y + this.agents[i].y_vel < this.agents[i].radius) {
                        this.agents[i].y_vel = -this.agents[i].y_vel;
                    }

                    this.agents[i].x += this.agents[i].x_vel;

                    if (this.agents[i].y >= this.height - this.agents[i].radius) {

                        this.agents[i].y_vel = Math.min(this.agents[i].y_vel, 0);
                        if (this.agents[i].y_vel == 0) {
                            this.agents[i].y = this.height - this.agents[i].radius;
                        } else {
                            this.agents[i].y += this.agents[i].y_vel;
                        }
                    } else {
                        this.agents[i].y_vel += this.g
                        this.agents[i].y += this.agents[i].y_vel;
                    }

                    if (this.distSq(this.user.x, this.user.y, this.agents[i].x, this.agents[i].y)
                        <= 0.6 * Math.pow(this.user.radius + this.agents[i].radius, 2)) {
                        // console.log()
                        return true;
                    }
                }
                return false;
            }

            detectCollisionAndUpdate() {
                // 1. Detect collision with side and top walls 
                if (this.user.x + this.user.x_vel > this.width - this.user.radius ||
                    this.user.x + this.user.x_vel < this.user.radius) {
                    this.user.x_vel = -this.user.x_vel;
                }
                if (this.user.y + this.user.y_vel < this.user.radius) {
                    this.user.y_vel = -this.user.y_vel;
                }

                // 2. Detect collision with platforms
                var isPlatformUnderneath = false;

                for (var i = 0; i < this.platforms.length; i++) {
                    if (this.user.x > this.platforms[i].x1 && this.user.x < this.platforms[i].x1 + this.platforms[i].width
                        && this.user.y < this.platforms[i].y1 && this.user.y + this.user.radius + this.user.y_vel >= this.platforms[i].y1 - platformHeight) {
                        this.user.y_vel = Math.min(this.user.y_vel, 0);
                        this.user.y = this.platforms[i].y1 - platformHeight - this.user.radius;
                        isPlatformUnderneath = true;
                        // console.log("platform under");
                    }
                }
                // 3. Floor detection and update velocities
                this.user.x += this.user.x_vel;
                if (this.user.y >= this.height - this.user.radius) {

                    this.user.y_vel = Math.min(this.user.y_vel, 0);
                    if (this.user.y_vel == 0) {
                        this.user.y = this.height - this.user.radius;
                    } else {
                        this.user.y += this.user.y_vel;
                    }
                }
                else if (!isPlatformUnderneath) {
                    this.user.y_vel += this.g
                    this.user.y += this.user.y_vel;
                }


            }
        }

        // console.log("hello" + user.radius);

        var collisionEngine = new CollisionDetection(canvas.width, canvas.height, user, platforms, agents, G);
        var GAME_OVER = false;

        function draw() {
            time += 1;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            user.drawUser(ctx);
            for (var i = 0; i < agents.length; i++) {
                agents[i].drawAgent(ctx);
            }
            for (var i = 0; i < platforms.length; i++) {
                platforms[i].drawPlatform(ctx);
            }
            // if (time % 10 == 0)

            if (GAME_OVER) {
                alert("GAME OVER");
                document.location.reload();
                clearInterval(interval);
            }

            //            console.log("t = " + time + " v_y = " + dy + " y = " + y);
            collisionEngine.detectCollisionAndUpdate();
            GAME_OVER = collisionEngine.detectCollisionWithAgentAndUpdate();

            // update for agent
            for (var i = 0; i < agents.length; i++) {
                var delta_x = user.x - agents[i].x;
                var delta_y = user.y - agents[i].y;
                agents[i].x_vel = Math.sign(delta_x) * AGENT_X_VEL;
                agents[i].y_vel = agents[i].y_vel == 0 ? Math.sign(delta_y) * AGENT_Y_VEL : agents[i].y_vel;
                // console.log("agent v_y " + agents[i].y_vel + " agent y " + agents[i].y);
            }

            if (rightPressed) {
                if (user.x_vel <= maxBallSpeed) {
                    user.x_vel += X_ACCL;
                }
            }
            else if (leftPressed) {
                if (user.x_vel >= -maxBallSpeed) {
                    user.x_vel -= X_ACCL;
                }
            }
            if (upPressed) {
                if (user.y_vel == 0) {
                    user.y_vel = -7.5;
                }
            }
        }


        document.addEventListener("keydown", keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);


        function keyDownHandler(e) {
            if (e.key == "Right" || e.key == "ArrowRight") {
                rightPressed = true;
            }
            else if (e.key == "Left" || e.key == "ArrowLeft") {
                leftPressed = true;
            }
            else if (e.key == "Up" || e.key == "ArrowUp") {
                upPressed = true;
            }
        }

        function keyUpHandler(e) {
            if (e.key == "Right" || e.key == "ArrowRight") {
                rightPressed = false;
            }
            else if (e.key == "Left" || e.key == "ArrowLeft") {
                leftPressed = false;
            }
            else if (e.key == "Up" || e.key == "ArrowUp") {
                upPressed = false;
            }
        }

        var interval = setInterval(draw, 10);

    </script>

</body>

</html>